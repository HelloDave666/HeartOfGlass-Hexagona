// src/adapters/primary/ui/controllers/ExerciseController.js
/**
 * ExerciseController - Gestion des exercices audio interactifs
 *
 * Responsabilit√©s :
 * - Gestion de l'interface des exercices
 * - Logique de l'exercice "Heart Of Frost"
 * - D√©tection de rotation r√©guli√®re du capteur
 * - Feedback utilisateur en temps r√©el
 *
 * Architecture : Adapter PRIMARY (UI)
 */

class ExerciseController {
  /**
   * @param {Object} config - Configuration
   * @param {Function} config.onStartExercise - Callback d√©marrage exercice
   * @param {Function} config.onStopExercise - Callback arr√™t exercice
   * @param {Object} config.audioOrchestrator - R√©f√©rence √† l'orchestrateur audio
   * @param {Object} config.state - R√©f√©rence au StateManager
   */
  constructor(config) {
    this.config = config || {};

    // Callbacks
    this.onStartExercise = config.onStartExercise || null;
    this.onStopExercise = config.onStopExercise || null;

    // R√©f√©rences externes
    this.audioOrchestrator = config.audioOrchestrator || null;
    this.state = config.state || null;

    // R√©f√©rences DOM
    this.heartOfFrostButton = null;
    this.stopExerciseButton = null;
    this.frostStatus = null;
    this.frostFeedback = null;

    // √âtat de l'exercice
    this.isExerciseActive = false;
    this.currentExercise = null;

    // Configuration Heart Of Frost
    this.frostConfig = {
      targetRotationTime: 3.0, // Temps cible pour une rotation compl√®te (secondes)
      rotationTimeWindow: 5, // Nombre de rotations pour calculer la moyenne
      timeTolerance: 0.5, // Tol√©rance (¬±0.5s)
      minSpeed: 0.1,
      maxSpeed: 3.0,
      smoothingFactor: 0.15 // Lissage tr√®s r√©actif
    };

    // √âtat de la rotation - D√©tection de rotations compl√®tes
    this.rotationState = {
      previousAngle: 0,
      currentAngle: 0,
      rotationCount: 0, // Nombre de rotations compl√®tes
      rotationStartTime: Date.now(),
      rotationTimes: [], // Historique des temps de rotation (en secondes)
      averageRotationTime: 0,
      currentDirection: 1, // 1 = positif, -1 = n√©gatif
      previousDirection: 1,
      playbackRate: 1.0,
      accumulatedAngle: 0 // Angle cumul√© pour d√©tecter les 360¬∞
    };

    // Stockage des handlers pour cleanup
    this.handlers = new Map();

    console.log('[ExerciseController] Initialis√©');
  }

  /**
   * Initialise le controller
   * @returns {boolean} - Succ√®s de l'initialisation
   */
  initialize() {
    console.log('[ExerciseController] Initialisation...');

    // R√©cup√©ration des √©l√©ments DOM
    this.heartOfFrostButton = document.getElementById('heartOfFrostButton');
    this.stopExerciseButton = document.getElementById('stopExerciseButton');
    this.frostStatus = document.getElementById('frostStatus');
    this.frostFeedback = document.getElementById('frostFeedback');

    // V√©rification des √©l√©ments essentiels
    if (!this.heartOfFrostButton || !this.frostStatus) {
      console.error('[ExerciseController] √âl√©ments UI essentiels manquants');
      return false;
    }

    // Configuration des √©v√©nements
    this.setupEventListeners();

    console.log('[ExerciseController] Interface exercices configur√©e');
    return true;
  }

  /**
   * Configure les √©couteurs d'√©v√©nements
   * @private
   */
  setupEventListeners() {
    // Bouton Heart Of Frost
    if (this.heartOfFrostButton) {
      const handler = () => this.startHeartOfFrost();
      this.handlers.set(this.heartOfFrostButton, { event: 'click', handler });
      this.heartOfFrostButton.addEventListener('click', handler);
    }

    // Bouton Stop
    if (this.stopExerciseButton) {
      const handler = () => this.stopExercise();
      this.handlers.set(this.stopExerciseButton, { event: 'click', handler });
      this.stopExerciseButton.addEventListener('click', handler);
    }
  }

  /**
   * D√©marre l'exercice Heart Of Frost
   * @public
   */
  startHeartOfFrost() {
    console.log('[ExerciseController] D√©marrage Heart Of Frost...');

    // V√©rifications pr√©alables
    if (!this.state) {
      this.updateStatus('Erreur: √âtat non disponible', 'error');
      return;
    }

    const audioState = this.state.getAudioState();
    const currentFile = this.state.getCurrentAudioFile();

    if (!currentFile) {
      this.updateStatus('‚ùå Chargez d\'abord un fichier audio !', 'error');
      return;
    }

    // Note: On ne v√©rifie pas explicitement les capteurs car ils peuvent se connecter pendant l'exercice
    // L'utilisateur verra le feedback en temps r√©el s'ils sont connect√©s ou non

    // Activation de l'exercice
    this.isExerciseActive = true;
    this.currentExercise = 'heartOfFrost';

    // D√©marrer la lecture audio si n√©cessaire
    if (!audioState.isPlaying && this.audioOrchestrator) {
      this.audioOrchestrator.togglePlayPause();
    }

    // Mise √† jour de l'interface
    this.heartOfFrostButton.style.display = 'none';
    this.stopExerciseButton.style.display = 'block';

    this.updateStatus('üéµ Exercice actif - Tournez r√©guli√®rement le capteur droit', 'active');
    this.updateFeedback('Rotation: En attente...');

    console.log('[ExerciseController] Heart Of Frost actif');

    // Callback
    if (this.onStartExercise) {
      this.onStartExercise('heartOfFrost');
    }
  }

  /**
   * Arr√™te l'exercice en cours
   * @public
   */
  stopExercise() {
    console.log('[ExerciseController] Arr√™t de l\'exercice...');

    this.isExerciseActive = false;
    this.currentExercise = null;

    // R√©initialiser l'√©tat de rotation
    this.rotationState = {
      previousAngle: 0,
      currentAngle: 0,
      rotationCount: 0,
      rotationStartTime: Date.now(),
      rotationTimes: [],
      averageRotationTime: 0,
      currentDirection: 1,
      previousDirection: 1,
      playbackRate: 1.0,
      accumulatedAngle: 0
    };

    // R√©initialiser la vitesse audio √† 1x
    if (this.audioOrchestrator) {
      this.audioOrchestrator.setPlaybackRate(1.0, 1);
    }

    // Mise √† jour de l'interface
    this.heartOfFrostButton.style.display = 'block';
    this.stopExerciseButton.style.display = 'none';

    this.updateStatus('‚úÖ Exercice termin√©', 'completed');
    this.updateFeedback('');

    // Callback
    if (this.onStopExercise) {
      this.onStopExercise();
    }
  }

  /**
   * Traite les donn√©es IMU pour l'exercice Heart Of Frost
   * LOGIQUE : D√©tecte les rotations compl√®tes et ajuste l'audio selon la r√©gularit√© sur plusieurs tours
   * @param {string} position - "GAUCHE" ou "DROIT"
   * @param {Object} angles - Angles du capteur { x, y, z }
   * @param {number} angularVelocity - Vitesse angulaire (¬∞/s)
   * @public
   */
  processIMUData(position, angles, angularVelocity) {
    // Ne traiter que si l'exercice Heart Of Frost est actif
    if (!this.isExerciseActive || this.currentExercise !== 'heartOfFrost') {
      return;
    }

    // Ne traiter que le capteur droit
    if (position !== 'DROIT') {
      return;
    }

    // R√©cup√©rer l'angle Y actuel
    const currentAngle = angles.y;
    const previousAngle = this.rotationState.previousAngle;

    // Calculer le changement d'angle depuis la derni√®re mesure
    let deltaAngle = currentAngle - previousAngle;

    // G√©rer le passage par 180¬∞ / -180¬∞ (wrap around)
    if (deltaAngle > 180) {
      deltaAngle -= 360;
    } else if (deltaAngle < -180) {
      deltaAngle += 360;
    }

    // Accumuler l'angle parcouru
    this.rotationState.accumulatedAngle += deltaAngle;

    // D√©terminer le sens de rotation
    const currentDirection = angularVelocity >= 0 ? 1 : -1;
    const hasDirectionChanged = (currentDirection !== this.rotationState.previousDirection);

    // Si inversion de sens, r√©initialiser l'accumulation
    if (hasDirectionChanged) {
      console.log('[HeartOfFrost] Inversion de sens d√©tect√©e !');
      this.rotationState.accumulatedAngle = 0;
      this.rotationState.rotationStartTime = Date.now();
      this.rotationState.previousDirection = currentDirection;
    }

    // D√©tecter une rotation compl√®te (360¬∞ parcourus)
    const absAccumulatedAngle = Math.abs(this.rotationState.accumulatedAngle);
    if (absAccumulatedAngle >= 360) {
      // Rotation compl√®te d√©tect√©e !
      const now = Date.now();
      const rotationTime = (now - this.rotationState.rotationStartTime) / 1000; // en secondes

      // Ajouter ce temps √† l'historique
      this.rotationState.rotationTimes.push(rotationTime);

      // Garder seulement les N derni√®res rotations
      if (this.rotationState.rotationTimes.length > this.frostConfig.rotationTimeWindow) {
        this.rotationState.rotationTimes.shift();
      }

      // Calculer le temps moyen
      const sum = this.rotationState.rotationTimes.reduce((a, b) => a + b, 0);
      this.rotationState.averageRotationTime = sum / this.rotationState.rotationTimes.length;

      // Incr√©menter le compteur
      this.rotationState.rotationCount++;

      console.log(`[HeartOfFrost] Rotation ${this.rotationState.rotationCount} compl√©t√©e en ${rotationTime.toFixed(2)}s | Moyenne: ${this.rotationState.averageRotationTime.toFixed(2)}s`);

      // R√©initialiser pour la prochaine rotation
      this.rotationState.accumulatedAngle = 0;
      this.rotationState.rotationStartTime = now;
    }

    // Calculer le playback rate bas√© sur la moyenne des rotations
    let playbackRate = 1.0;
    let playbackDirection = currentDirection;

    if (this.rotationState.rotationTimes.length >= 2) {
      // On a assez de donn√©es pour calculer
      const avgTime = this.rotationState.averageRotationTime;
      const targetTime = this.frostConfig.targetRotationTime;
      const tolerance = this.frostConfig.timeTolerance;

      if (avgTime < (targetTime - tolerance)) {
        // TROP RAPIDE : Acc√©l√©ration
        const timeDiff = targetTime - avgTime;
        playbackRate = 1.0 + (timeDiff * 0.5); // Facteur d'acc√©l√©ration
        playbackRate = Math.min(this.frostConfig.maxSpeed, playbackRate);
      } else if (avgTime > (targetTime + tolerance)) {
        // TROP LENT : Ralentissement
        const timeDiff = avgTime - targetTime;
        playbackRate = 1.0 - (timeDiff * 0.3); // Facteur de ralentissement
        playbackRate = Math.max(this.frostConfig.minSpeed, playbackRate);
      } else {
        // R√âGULIER : Vitesse normale
        playbackRate = 1.0;
      }
    }

    // Lissage du playback rate
    this.rotationState.playbackRate =
      this.rotationState.playbackRate * (1 - this.frostConfig.smoothingFactor) +
      playbackRate * this.frostConfig.smoothingFactor;

    // Appliquer √† l'audio
    if (this.audioOrchestrator) {
      this.audioOrchestrator.setPlaybackRate(
        this.rotationState.playbackRate,
        playbackDirection
      );
    }

    // Mettre √† jour les variables pour la prochaine it√©ration
    this.rotationState.previousAngle = currentAngle;
    this.rotationState.currentAngle = currentAngle;
    this.rotationState.currentDirection = currentDirection;

    // Mettre √† jour le feedback
    if (!this.lastFeedbackUpdate || Date.now() - this.lastFeedbackUpdate > 100) {
      this.updateExerciseFeedback();
      this.lastFeedbackUpdate = Date.now();
    }
  }

  /**
   * Met √† jour le feedback de l'exercice
   * @private
   */
  updateExerciseFeedback() {
    const rotationCount = this.rotationState.rotationCount;
    const avgTime = this.rotationState.averageRotationTime;
    const rate = this.rotationState.playbackRate;
    const targetTime = this.frostConfig.targetRotationTime;
    const tolerance = this.frostConfig.timeTolerance;

    let feedback = '';
    let emoji = '';
    let status = '';

    // D√©terminer le statut
    if (this.rotationState.rotationTimes.length < 2) {
      // Pas assez de donn√©es
      emoji = 'üîÑ';
      status = 'En cours de calibration...';
      feedback = `${emoji} ${status} | Rotations: ${rotationCount} | En rotation...`;
    } else {
      // Assez de donn√©es pour √©valuer
      if (avgTime >= (targetTime - tolerance) && avgTime <= (targetTime + tolerance)) {
        // R√âGULIER !
        emoji = '‚úÖ';
        status = 'PARFAIT ! Rythme r√©gulier';
      } else if (avgTime < (targetTime - tolerance)) {
        // TROP RAPIDE
        if (rate >= 2.5) {
          emoji = '‚ö°‚ö°‚ö°';
          status = 'BEAUCOUP TROP RAPIDE !';
        } else if (rate >= 1.5) {
          emoji = '‚ö°‚ö°';
          status = 'TROP RAPIDE !';
        } else {
          emoji = '‚ö°';
          status = 'Un peu trop rapide';
        }
      } else {
        // TROP LENT
        if (rate <= 0.5) {
          emoji = 'üêåüêå';
          status = 'BEAUCOUP TROP LENT !';
        } else {
          emoji = 'üêå';
          status = 'Trop lent';
        }
      }

      feedback = `${emoji} ${status} | Rotations: ${rotationCount} | Temps moyen: ${avgTime.toFixed(2)}s (cible: ${targetTime}s) | Audio: ${rate.toFixed(2)}x`;
    }

    this.updateFeedback(feedback);
  }

  /**
   * Met √† jour le statut de l'exercice
   * @param {string} message - Message √† afficher
   * @param {string} type - Type de statut ('active', 'error', 'completed')
   * @private
   */
  updateStatus(message, type = 'info') {
    if (!this.frostStatus) return;

    this.frostStatus.textContent = message;

    // Couleurs selon le type
    const colors = {
      active: '#00bfff',
      error: '#e74c3c',
      completed: '#2ecc71',
      info: '#95a5a6'
    };

    this.frostStatus.style.color = colors[type] || colors.info;
  }

  /**
   * Met √† jour le feedback en temps r√©el
   * @param {string} message - Message de feedback
   * @private
   */
  updateFeedback(message) {
    if (!this.frostFeedback) return;
    this.frostFeedback.textContent = message;
  }

  /**
   * V√©rifie si un exercice est actif
   * @returns {boolean}
   * @public
   */
  isActive() {
    return this.isExerciseActive;
  }

  /**
   * Obtient l'exercice actuel
   * @returns {string|null}
   * @public
   */
  getCurrentExercise() {
    return this.currentExercise;
  }

  /**
   * Nettoie les ressources
   * @public
   */
  dispose() {
    console.log('[ExerciseController] Nettoyage...');

    // Arr√™ter l'exercice si actif
    if (this.isExerciseActive) {
      this.stopExercise();
    }

    // Suppression des event listeners
    this.handlers.forEach((data, element) => {
      element.removeEventListener(data.event, data.handler);
    });
    this.handlers.clear();

    // Nettoyage des r√©f√©rences
    this.heartOfFrostButton = null;
    this.stopExerciseButton = null;
    this.frostStatus = null;
    this.frostFeedback = null;
    this.audioOrchestrator = null;
    this.state = null;

    console.log('[ExerciseController] Nettoy√©');
  }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ExerciseController;
}
