// src/adapters/primary/ui/controllers/ExerciseController.js
/**
 * ExerciseController - Gestion des exercices audio interactifs
 *
 * Responsabilit√©s :
 * - Gestion de l'interface des exercices
 * - Logique de l'exercice "Heart Of Frost"
 * - D√©tection de rotation r√©guli√®re du capteur
 * - Feedback utilisateur en temps r√©el
 *
 * Architecture : Adapter PRIMARY (UI)
 */

class ExerciseController {
  /**
   * @param {Object} config - Configuration
   * @param {Function} config.onStartExercise - Callback d√©marrage exercice
   * @param {Function} config.onStopExercise - Callback arr√™t exercice
   * @param {Object} config.audioOrchestrator - R√©f√©rence √† l'orchestrateur audio
   * @param {Object} config.state - R√©f√©rence au StateManager
   */
  constructor(config) {
    this.config = config || {};

    // Callbacks
    this.onStartExercise = config.onStartExercise || null;
    this.onStopExercise = config.onStopExercise || null;

    // R√©f√©rences externes
    this.audioOrchestrator = config.audioOrchestrator || null;
    this.state = config.state || null;

    // R√©f√©rences DOM
    this.heartOfFrostButton = null;
    this.stopExerciseButton = null;
    this.frostStatus = null;
    this.frostFeedback = null;

    // √âtat de l'exercice
    this.isExerciseActive = false;
    this.currentExercise = null;

    // Configuration Heart Of Frost
    this.frostConfig = {
      neutralZone: 5, // Zone neutre autour de 0¬∞ (¬±5¬∞)
      maxAngle: 45, // Angle maximal pour atteindre la vitesse max (45¬∞)
      minSpeed: 0.1,
      maxSpeed: 3.0,
      smoothingFactor: 0.3
    };

    // √âtat de la rotation
    this.rotationState = {
      currentAngle: 0,
      direction: 1,
      playbackRate: 1.0,
      isInNeutralZone: true
    };

    // Stockage des handlers pour cleanup
    this.handlers = new Map();

    console.log('[ExerciseController] Initialis√©');
  }

  /**
   * Initialise le controller
   * @returns {boolean} - Succ√®s de l'initialisation
   */
  initialize() {
    console.log('[ExerciseController] Initialisation...');

    // R√©cup√©ration des √©l√©ments DOM
    this.heartOfFrostButton = document.getElementById('heartOfFrostButton');
    this.stopExerciseButton = document.getElementById('stopExerciseButton');
    this.frostStatus = document.getElementById('frostStatus');
    this.frostFeedback = document.getElementById('frostFeedback');

    // V√©rification des √©l√©ments essentiels
    if (!this.heartOfFrostButton || !this.frostStatus) {
      console.error('[ExerciseController] √âl√©ments UI essentiels manquants');
      return false;
    }

    // Configuration des √©v√©nements
    this.setupEventListeners();

    console.log('[ExerciseController] Interface exercices configur√©e');
    return true;
  }

  /**
   * Configure les √©couteurs d'√©v√©nements
   * @private
   */
  setupEventListeners() {
    // Bouton Heart Of Frost
    if (this.heartOfFrostButton) {
      const handler = () => this.startHeartOfFrost();
      this.handlers.set(this.heartOfFrostButton, { event: 'click', handler });
      this.heartOfFrostButton.addEventListener('click', handler);
    }

    // Bouton Stop
    if (this.stopExerciseButton) {
      const handler = () => this.stopExercise();
      this.handlers.set(this.stopExerciseButton, { event: 'click', handler });
      this.stopExerciseButton.addEventListener('click', handler);
    }
  }

  /**
   * D√©marre l'exercice Heart Of Frost
   * @public
   */
  startHeartOfFrost() {
    console.log('[ExerciseController] D√©marrage Heart Of Frost...');

    // V√©rifications pr√©alables
    if (!this.state) {
      this.updateStatus('Erreur: √âtat non disponible', 'error');
      return;
    }

    const audioState = this.state.getAudioState();
    const currentFile = this.state.getCurrentAudioFile();

    if (!currentFile) {
      this.updateStatus('‚ùå Chargez d\'abord un fichier audio !', 'error');
      return;
    }

    // Note: On ne v√©rifie pas explicitement les capteurs car ils peuvent se connecter pendant l'exercice
    // L'utilisateur verra le feedback en temps r√©el s'ils sont connect√©s ou non

    // Activation de l'exercice
    this.isExerciseActive = true;
    this.currentExercise = 'heartOfFrost';

    // D√©marrer la lecture audio si n√©cessaire
    if (!audioState.isPlaying && this.audioOrchestrator) {
      this.audioOrchestrator.togglePlayPause();
    }

    // Mise √† jour de l'interface
    this.heartOfFrostButton.style.display = 'none';
    this.stopExerciseButton.style.display = 'block';

    this.updateStatus('üéµ Exercice actif - Tournez r√©guli√®rement le capteur droit', 'active');
    this.updateFeedback('Rotation: En attente...');

    console.log('[ExerciseController] Heart Of Frost actif');

    // Callback
    if (this.onStartExercise) {
      this.onStartExercise('heartOfFrost');
    }
  }

  /**
   * Arr√™te l'exercice en cours
   * @public
   */
  stopExercise() {
    console.log('[ExerciseController] Arr√™t de l\'exercice...');

    this.isExerciseActive = false;
    this.currentExercise = null;

    // R√©initialiser l'√©tat de rotation
    this.rotationState = {
      currentAngle: 0,
      direction: 1,
      playbackRate: 1.0,
      isInNeutralZone: true
    };

    // R√©initialiser la vitesse audio √† 1x
    if (this.audioOrchestrator) {
      this.audioOrchestrator.setPlaybackRate(1.0, 1);
    }

    // Mise √† jour de l'interface
    this.heartOfFrostButton.style.display = 'block';
    this.stopExerciseButton.style.display = 'none';

    this.updateStatus('‚úÖ Exercice termin√©', 'completed');
    this.updateFeedback('');

    // Callback
    if (this.onStopExercise) {
      this.onStopExercise();
    }
  }

  /**
   * Traite les donn√©es IMU pour l'exercice Heart Of Frost
   * LOGIQUE LIN√âAIRE : Bas√©e sur la POSITION angulaire, pas la vitesse
   * @param {string} position - "GAUCHE" ou "DROIT"
   * @param {Object} angles - Angles du capteur { x, y, z }
   * @param {number} angularVelocity - Vitesse angulaire (¬∞/s) - non utilis√©e
   * @public
   */
  processIMUData(position, angles, angularVelocity) {
    // Ne traiter que si l'exercice Heart Of Frost est actif
    if (!this.isExerciseActive || this.currentExercise !== 'heartOfFrost') {
      return;
    }

    // Ne traiter que le capteur droit
    if (position !== 'DROIT') {
      return;
    }

    // R√©cup√©rer l'angle Y (inclinaison avant/arri√®re)
    const currentAngle = angles.y;
    this.rotationState.currentAngle = currentAngle;

    // D√©terminer si on est dans la zone neutre
    const neutralZone = this.frostConfig.neutralZone;
    const isInNeutralZone = Math.abs(currentAngle) <= neutralZone;
    this.rotationState.isInNeutralZone = isInNeutralZone;

    // Calculer le playback rate et la direction
    let playbackRate;
    let direction;

    if (isInNeutralZone) {
      // Zone neutre : vitesse normale
      playbackRate = 1.0;
      direction = 1;
    } else {
      // Hors zone neutre : mapper lin√©airement l'angle vers le playback rate
      const angleFromNeutral = Math.abs(currentAngle) - neutralZone;
      const maxAngle = this.frostConfig.maxAngle;

      // Mapper lin√©airement de neutralZone √† maxAngle ‚Üí 1.0x √† 3.0x
      const normalizedAngle = Math.min(angleFromNeutral / maxAngle, 1.0);
      playbackRate = 1.0 + (normalizedAngle * (this.frostConfig.maxSpeed - 1.0));

      // Limiter entre min et max
      playbackRate = Math.max(this.frostConfig.minSpeed,
                             Math.min(this.frostConfig.maxSpeed, playbackRate));

      // Direction : positif = avant, n√©gatif = arri√®re
      direction = currentAngle >= 0 ? 1 : -1;
    }

    // Lissage du playback rate pour √©viter les variations brusques
    this.rotationState.playbackRate =
      this.rotationState.playbackRate * (1 - this.frostConfig.smoothingFactor) +
      playbackRate * this.frostConfig.smoothingFactor;

    this.rotationState.direction = direction;

    // Appliquer √† l'audio
    if (this.audioOrchestrator) {
      this.audioOrchestrator.setPlaybackRate(
        this.rotationState.playbackRate,
        this.rotationState.direction
      );
    }

    // Mettre √† jour le feedback (toutes les 100ms environ)
    if (!this.lastFeedbackUpdate || Date.now() - this.lastFeedbackUpdate > 100) {
      this.updateExerciseFeedback();
      this.lastFeedbackUpdate = Date.now();
    }
  }

  /**
   * Met √† jour le feedback de l'exercice
   * @private
   */
  updateExerciseFeedback() {
    const angle = this.rotationState.currentAngle;
    const rate = this.rotationState.playbackRate;
    const direction = this.rotationState.direction;
    const isInNeutralZone = this.rotationState.isInNeutralZone;

    let feedback = '';
    let emoji = '';

    if (isInNeutralZone) {
      emoji = '‚úÖ';
      feedback = `ZONE NEUTRE ! Vitesse normale (1.0x) | Angle: ${angle.toFixed(1)}¬∞`;
    } else if (direction > 0) {
      // Inclinaison vers l'avant (positif)
      if (rate > 2.0) {
        emoji = '‚ö°‚ö°';
        feedback = `Acc√©l√©ration RAPIDE ! (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      } else if (rate > 1.5) {
        emoji = '‚ö°';
        feedback = `Acc√©l√©ration ! (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      } else {
        emoji = '‚Üí';
        feedback = `Acc√©l√©ration l√©g√®re (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      }
    } else {
      // Inclinaison vers l'arri√®re (n√©gatif)
      if (rate > 2.0) {
        emoji = '‚Ü©Ô∏è‚Ü©Ô∏è';
        feedback = `Lecture INVERSE RAPIDE ! (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      } else if (rate > 1.5) {
        emoji = '‚Ü©Ô∏è';
        feedback = `Lecture INVERSE ! (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      } else {
        emoji = '‚Üê';
        feedback = `Lecture inverse l√©g√®re (${rate.toFixed(2)}x) | Angle: ${angle.toFixed(1)}¬∞`;
      }
    }

    this.updateFeedback(`${emoji} ${feedback}`);
  }

  /**
   * Met √† jour le statut de l'exercice
   * @param {string} message - Message √† afficher
   * @param {string} type - Type de statut ('active', 'error', 'completed')
   * @private
   */
  updateStatus(message, type = 'info') {
    if (!this.frostStatus) return;

    this.frostStatus.textContent = message;

    // Couleurs selon le type
    const colors = {
      active: '#00bfff',
      error: '#e74c3c',
      completed: '#2ecc71',
      info: '#95a5a6'
    };

    this.frostStatus.style.color = colors[type] || colors.info;
  }

  /**
   * Met √† jour le feedback en temps r√©el
   * @param {string} message - Message de feedback
   * @private
   */
  updateFeedback(message) {
    if (!this.frostFeedback) return;
    this.frostFeedback.textContent = message;
  }

  /**
   * V√©rifie si un exercice est actif
   * @returns {boolean}
   * @public
   */
  isActive() {
    return this.isExerciseActive;
  }

  /**
   * Obtient l'exercice actuel
   * @returns {string|null}
   * @public
   */
  getCurrentExercise() {
    return this.currentExercise;
  }

  /**
   * Nettoie les ressources
   * @public
   */
  dispose() {
    console.log('[ExerciseController] Nettoyage...');

    // Arr√™ter l'exercice si actif
    if (this.isExerciseActive) {
      this.stopExercise();
    }

    // Suppression des event listeners
    this.handlers.forEach((data, element) => {
      element.removeEventListener(data.event, data.handler);
    });
    this.handlers.clear();

    // Nettoyage des r√©f√©rences
    this.heartOfFrostButton = null;
    this.stopExerciseButton = null;
    this.frostStatus = null;
    this.frostFeedback = null;
    this.audioOrchestrator = null;
    this.state = null;

    console.log('[ExerciseController] Nettoy√©');
  }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ExerciseController;
}
