// src/adapters/primary/ui/app.js
// Version corrigée avec gestion manuelle de la reconnexion

const noble = require('noble-winrt');

console.log('Heart of Glass - Version corrigee');

// ==========================================
// CONFIGURATION ET ETAT GLOBAL
// ==========================================
const SENSOR_CONFIG = {
  leftAddress: 'ce:de:c2:f5:17:be',
  rightAddress: 'f0:70:c4:de:d1:22',
  leftColor: 'blue', 
  rightColor: 'green',
  scanTimeout: 20000,  // Timeout de scan : 20 secondes
  reconnectDelay: 5000 // Délai avant reconnexion : 5 secondes
};

// État global simplifié avec une seule source de vérité
const globalState = {
  peripherals: new Map(),     // Map<address, peripheral>
  connections: new Map(),     // Map<address, connectionInfo>
  characteristics: new Map(), // Map<address, characteristics[]>
  dataReceived: new Set(),    // Set<address>
  isScanning: false,
  autoReconnect: false,       // Désactiver la reconnexion automatique par défaut
  reconnectTimers: new Map()  // Map<address, timeoutId>
};

// Variables UI
let scanButton = null;
let deviceList = null;
let errorDisplay = null;

// ==========================================
// FONCTIONS UTILITAIRES
// ==========================================
function getSensorInfo(address) {
  const addrLower = address.toLowerCase();
  if (addrLower === SENSOR_CONFIG.leftAddress.toLowerCase()) {
    return { position: 'GAUCHE', color: SENSOR_CONFIG.leftColor };
  }
  if (addrLower === SENSOR_CONFIG.rightAddress.toLowerCase()) {
    return { position: 'DROIT', color: SENSOR_CONFIG.rightColor };
  }
  return { position: 'INCONNU', color: 'black' };
}

function normalizeAngle(angle, preserveFullRange = false) {
  if (preserveFullRange) {
    while (angle > 180) angle -= 360;
    while (angle < -180) angle += 360;
    return angle;
  }
  angle = angle % 360;
  if (angle < 0) angle += 360;
  return angle;
}

// ==========================================
// GESTION DE L'ETAT
// ==========================================
function isSensorConnected(address) {
  const addrLower = address.toLowerCase();
  return globalState.connections.has(addrLower) && 
         globalState.connections.get(addrLower).connected;
}

function isSensorReceivingData(address) {
  return globalState.dataReceived.has(address.toLowerCase());
}

function areBothSensorsOperational() {
  const leftConnected = isSensorConnected(SENSOR_CONFIG.leftAddress);
  const rightConnected = isSensorConnected(SENSOR_CONFIG.rightAddress);
  const leftData = isSensorReceivingData(SENSOR_CONFIG.leftAddress);
  const rightData = isSensorReceivingData(SENSOR_CONFIG.rightAddress);
  
  console.log(`[Etat] Gauche: ${leftConnected ? 'connecte' : 'deconnecte'}, ${leftData ? 'donnees OK' : 'pas de donnees'}`);
  console.log(`[Etat] Droit: ${rightConnected ? 'connecte' : 'deconnecte'}, ${rightData ? 'donnees OK' : 'pas de donnees'}`);
  
  return leftConnected && rightConnected && leftData && rightData;
}

// ==========================================
// NETTOYAGE ET RESET
// ==========================================
function cleanupPeripheral(address) {
  const addrLower = address.toLowerCase();
  console.log(`[Nettoyage] Nettoyage complet pour ${address}`);
  
  // Annuler le timer de reconnexion si existant
  if (globalState.reconnectTimers.has(addrLower)) {
    clearTimeout(globalState.reconnectTimers.get(addrLower));
    globalState.reconnectTimers.delete(addrLower);
  }
  
  // Nettoyer les caractéristiques
  if (globalState.characteristics.has(addrLower)) {
    const chars = globalState.characteristics.get(addrLower);
    chars.forEach(char => {
      try {
        char.removeAllListeners('data');
      } catch (e) {
        // Ignorer les erreurs
      }
    });
    globalState.characteristics.delete(addrLower);
  }
  
  // Nettoyer le périphérique
  if (globalState.peripherals.has(addrLower)) {
    const peripheral = globalState.peripherals.get(addrLower);
    try {
      peripheral.removeAllListeners();
    } catch (e) {
      // Ignorer les erreurs
    }
    globalState.peripherals.delete(addrLower);
  }
  
  // Mettre à jour l'état
  globalState.connections.delete(addrLower);
  globalState.dataReceived.delete(addrLower);
}

function resetAllState() {
  console.log('[Reset] Reinitialisation complete de letat');
  
  // Nettoyer tous les périphériques
  globalState.peripherals.forEach((peripheral, address) => {
    cleanupPeripheral(address);
  });
  
  // Réinitialiser toutes les maps
  globalState.peripherals.clear();
  globalState.connections.clear();
  globalState.characteristics.clear();
  globalState.dataReceived.clear();
  globalState.reconnectTimers.clear();
  globalState.isScanning = false;
}

// ==========================================
// INTERFACE UTILISATEUR
// ==========================================
function createDeviceDisplay(position, color, address) {
  console.log(`[UI] Creation affichage pour ${position} (${address})`);
  const deviceDiv = document.createElement('div');
  deviceDiv.className = 'device-info';
  deviceDiv.setAttribute('data-address', address);
  deviceDiv.innerHTML = `
    <div class="status-indicator status-disconnected"></div>
    <div class="info-basic">
      <h3 style="color: ${color}">Capteur ${position}</h3>
      <p style="color: ${color}">Adresse: ${address}</p>
      <p style="color: ${color}">RSSI: --</p>
      <p style="color: ${color}">Force du signal: --%</p>
      <p style="color: ${color}">Etat: deconnecte</p>
      <p style="color: ${color}">Batterie: --%</p>
    </div>
    <div class="info-sensor">
      <h3>Donnees capteur</h3>
      <p style="color: ${color}">Roll (X): --°</p>
      <p style="color: ${color}">Pitch (Y): --°</p>
      <p style="color: ${color}">Yaw (Z): --°</p>
    </div>
  `;
  return deviceDiv;
}

function updateDeviceStatus(address, connected) {
  const deviceDiv = document.querySelector(`[data-address="${address}"]`);
  if (!deviceDiv) return;
  
  const { position, color } = getSensorInfo(address);
  console.log(`[UI] ${position}: ${connected ? 'connecte' : 'deconnecte'}`);
  
  const indicator = deviceDiv.querySelector('.status-indicator');
  if (indicator) {
    indicator.className = `status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`;
  }
  
  const stateText = deviceDiv.querySelector('.info-basic p:nth-child(5)');
  if (stateText) {
    const p = /** @type {HTMLElement} */ (stateText);
    p.style.color = color;
    stateText.textContent = `Etat: ${connected ? 'connecte' : 'deconnecte'}`;
  }
}

function updateDeviceInfo(peripheral) {
  const deviceDiv = document.querySelector(`[data-address="${peripheral.address}"]`);
  if (!deviceDiv) return;
  
  const { position, color } = getSensorInfo(peripheral.address);
  const infoBasic = deviceDiv.querySelector('.info-basic');
  if (!infoBasic) return;
  
  // Préserver la batterie
  let batteryText = 'Batterie: --%';
  const batteryElement = deviceDiv.querySelector('.info-basic p:nth-child(6)');
  if (batteryElement) {
    batteryText = batteryElement.textContent;
  }
  
  infoBasic.innerHTML = `
    <h3 style="color: ${color}">Capteur ${position}</h3>
    <p style="color: ${color}">Adresse: ${peripheral.address}</p>
    <p style="color: ${color}">RSSI: ${peripheral.rssi}dBm</p>
    <p style="color: ${color}">Force du signal: ${Math.min(100, Math.max(0, 100 + peripheral.rssi))}%</p>
    <p style="color: ${color}">Etat: connecte</p>
    <p style="color: ${color}">${batteryText}</p>
  `;
}

function updateSensorData(address, data) {
  const deviceDiv = document.querySelector(`[data-address="${address}"]`);
  if (!deviceDiv) return;
  
  const { color } = getSensorInfo(address);
  const sensorDataDiv = deviceDiv.querySelector('.info-sensor');
  if (sensorDataDiv) {
    sensorDataDiv.innerHTML = `
      <h3>Donnees capteur</h3>
      <p style="color: ${color}">Roll (X): ${data.x}°</p>
      <p style="color: ${color}">Pitch (Y): ${data.y}°</p>
      <p style="color: ${color}">Yaw (Z): ${data.z}°</p>
    `;
  }
}

function updateScanButton(text, color, enabled) {
  if (!scanButton) return;
  scanButton.disabled = !enabled;
  scanButton.style.backgroundColor = color;
  scanButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
  scanButton.textContent = text;
  console.log(`[UI] Bouton: "${text}", ${enabled ? 'active' : 'desactive'}`);
}

// ==========================================
// SCAN ET DECOUVERTE
// ==========================================
function startScanning() {
  if (globalState.isScanning) return;
  
  console.log('[Scan] Demarrage du scan');
  globalState.isScanning = true;
  
  // Reset complet avant de scanner
  resetAllState();
  
  // UI
  updateScanButton('Recherche en cours...', '#e74c3c', false);
  if (deviceList) {
    deviceList.innerHTML = '';
    deviceList.appendChild(createDeviceDisplay('GAUCHE', SENSOR_CONFIG.leftColor, SENSOR_CONFIG.leftAddress));
    deviceList.appendChild(createDeviceDisplay('DROIT', SENSOR_CONFIG.rightColor, SENSOR_CONFIG.rightAddress));
  }
  
  // Démarrer le scan
  noble.startScanning();
  
  // Timeout de scan
  setTimeout(() => {
    if (globalState.isScanning) {
      console.log('[Scan] Timeout atteint, arret du scan');
      stopScanning();
      
      // Toujours réactiver le bouton après timeout
      updateScanButton('Rechercher les capteurs', '#4CAF50', true);
    }
  }, SENSOR_CONFIG.scanTimeout);
}

function stopScanning() {
  if (!globalState.isScanning) return;
  
  console.log('[Scan] Arret du scan');
  globalState.isScanning = false;
  noble.stopScanning();
}

// ==========================================
// CONNEXION ET GESTION DES DONNEES
// ==========================================
function connectToPeripheral(peripheral) {
  const address = peripheral.address.toLowerCase();
  const { position } = getSensorInfo(peripheral.address);
  
  // Verifier si deja connecte
  if (isSensorConnected(peripheral.address)) {
    console.log(`[Connexion] ${position} deja connecte`);
    return;
  }
  
  // Nettoyer toute connexion précédente
  cleanupPeripheral(address);
  
  // Stocker le périphérique
  globalState.peripherals.set(address, peripheral);
  
  console.log(`[Connexion] Tentative connexion ${position}...`);
  
  peripheral.connect((error) => {
    if (error) {
      console.error(`[Connexion] Erreur ${position}:`, error);
      updateDeviceStatus(peripheral.address, false);
      return;
    }
    
    console.log(`[Connexion] ${position} connecte avec succes`);
    globalState.connections.set(address, { connected: true, timestamp: Date.now() });
    updateDeviceStatus(peripheral.address, true);
    updateDeviceInfo(peripheral);
    
    // Configuration de la deconnexion
    peripheral.once('disconnect', () => {
      console.log(`[Deconnexion] ${position} deconnecte`);
      handleDisconnection(peripheral.address);
    });
    
    // Découvrir les services
    setTimeout(() => {
      discoverServices(peripheral);
    }, 100);
  });
}

function discoverServices(peripheral) {
  const address = peripheral.address.toLowerCase();
  const { position } = getSensorInfo(peripheral.address);
  
  peripheral.discoverAllServicesAndCharacteristics((error, services, characteristics) => {
    if (error) {
      console.error(`[Services] Erreur decouverte ${position}:`, error);
      return;
    }
    
    console.log(`[Services] ${characteristics.length} caracteristiques trouvees pour ${position}`);
    
    // Stocker les caractéristiques
    globalState.characteristics.set(address, characteristics);
    
    // Envoi commande batterie (gauche uniquement)
    if (address === SENSOR_CONFIG.leftAddress.toLowerCase() && characteristics.length > 0) {
      const batteryCmd = Buffer.from([0xFF, 0xAA, 0x27, 0x64, 0x00]);
      characteristics[0].write(batteryCmd, true, (error) => {
        if (!error) console.log('[Batterie] Commande envoyee');
      });
    }
    
    // Activer les notifications
    setupNotifications(peripheral, characteristics);
  });
}

function setupNotifications(peripheral, characteristics) {
  const address = peripheral.address.toLowerCase();
  const { position } = getSensorInfo(peripheral.address);
  let notificationsEnabled = 0;
  
  characteristics.forEach((characteristic, index) => {
    characteristic.notify(true, (error) => {
      if (error) {
        console.error(`[Notification] Erreur ${position} char ${index}:`, error);
        return;
      }
      
      notificationsEnabled++;
      console.log(`[Notification] ${position}: ${notificationsEnabled}/${characteristics.length} activees`);
      
      // IMPORTANT: Nettoyer les anciens listeners avant d'en ajouter de nouveaux
      characteristic.removeAllListeners('data');
      
      // Configurer le listener de données
      characteristic.on('data', (data) => {
        handleSensorData(peripheral.address, data);
      });
    });
  });
}

// Gestionnaire centralise des donnees
const calibrationOffsets = new Map();

function handleSensorData(address, data) {
  if (!data || data.length < 1) return;
  
  const addrLower = address.toLowerCase();
  const { position } = getSensorInfo(address);
  
  // Traiter selon le type de données
  if (data[0] === 0x55) {
    // Données de batterie (gauche uniquement)
    if (data[1] === 0x71 && addrLower === SENSOR_CONFIG.leftAddress.toLowerCase()) {
      updateBatteryLevel(address, data);
    }
    // Données d'angle
    else if (data[1] === 0x61 && data.length >= 20) {
      // Marquer comme recevant des données
      if (!globalState.dataReceived.has(addrLower)) {
        console.log(`[Donnees] Premiere reception pour ${position}`);
        globalState.dataReceived.add(addrLower);
      }
      
      // Traiter les angles
      const angles = processAngleData(data, address);
      if (angles) {
        updateSensorData(address, angles);
      }
      
      // Verifier si tout est operationnel
      if (areBothSensorsOperational()) {
        stopScanning();
        updateScanButton('Capteurs operationnels', '#3498db', false);
      }
    }
  }
}

function processAngleData(data, address) {
  let angles = {
    x: ((data[15] << 8 | data[14]) / 32768 * 180),
    y: ((data[17] << 8 | data[16]) / 32768 * 180),
    z: ((data[19] << 8 | data[18]) / 32768 * 180)
  };
  
  // Calibration
  if (!calibrationOffsets.has(address)) {
    calibrationOffsets.set(address, { x: angles.x, y: angles.y, z: angles.z });
  }
  
  const offsets = calibrationOffsets.get(address);
  return {
    x: normalizeAngle(angles.x - offsets.x, true).toFixed(1),
    y: normalizeAngle(angles.y - offsets.y, true).toFixed(1),
    z: normalizeAngle(angles.z - offsets.z, true).toFixed(1)
  };
}

function updateBatteryLevel(address, data) {
  if (data.length < 6 || data[0] !== 0x55 || data[1] !== 0x71) return;
  
  const batteryValue = (data[5] << 8) | data[4];
  let percentage = 0;
  
  // Calcul du pourcentage
  if (batteryValue > 830) percentage = 100;
  else if (batteryValue > 393) percentage = 90;
  else if (batteryValue > 387) percentage = 75;
  else if (batteryValue > 382) percentage = 60;
  else if (batteryValue > 379) percentage = 50;
  else if (batteryValue > 377) percentage = 40;
  else if (batteryValue > 373) percentage = 30;
  else if (batteryValue > 370) percentage = 20;
  else if (batteryValue > 368) percentage = 15;
  else if (batteryValue > 350) percentage = 10;
  else percentage = 5;
  
  const deviceDiv = document.querySelector(`[data-address="${address}"]`);
  if (deviceDiv) {
    const batteryText = deviceDiv.querySelector('.info-basic p:nth-child(6)');
    if (batteryText) {
      const { color } = getSensorInfo(address);
      const p = /** @type {HTMLElement} */ (batteryText);
      p.style.color = color;
      batteryText.textContent = `Batterie: ${percentage}%`;
    }
  }
}

// ==========================================
// GESTION DES DECONNEXIONS ET RECONNEXIONS
// ==========================================
function handleDisconnection(address) {
  const addrLower = address.toLowerCase();
  const { position } = getSensorInfo(address);
  
  console.log(`[Deconnexion] Gestion deconnexion ${position}`);
  
  // Nettoyer l'état
  cleanupPeripheral(address);
  
  // Mettre à jour l'UI
  updateDeviceStatus(address, false);
  
  // Si le scan n'est pas en cours, réactiver le bouton
  if (!globalState.isScanning) {
    updateScanButton('Rechercher les capteurs', '#4CAF50', true);
  }
}

// ==========================================
// CONFIGURATION NOBLE
// ==========================================
function setupNoble() {
  console.log('[Noble] Configuration...');
  
  noble.on('stateChange', (state) => {
    console.log('[Noble] Etat:', state);
    if (state === 'poweredOn' && scanButton && !globalState.isScanning) {
      updateScanButton('Rechercher les capteurs', '#4CAF50', true);
    }
  });
  
  noble.on('discover', (peripheral) => {
    if (!peripheral.advertisement.localName?.includes('WT901BLE67')) return;
    
    const { position } = getSensorInfo(peripheral.address);
    console.log(`[Decouverte] ${position} trouve: ${peripheral.address}`);
    
    // Se connecter immédiatement
    connectToPeripheral(peripheral);
  });
  
  // Surveiller les erreurs Noble
  noble.on('error', (error) => {
    console.error('[Noble] Erreur:', error);
  });
}

// ==========================================
// INTERFACE UTILISATEUR
// ==========================================
function setupTabs() {
  const tabButtons = document.querySelectorAll('.tab-button');
  const tabContents = document.querySelectorAll('.tab-content');
  
  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      const tabId = button.getAttribute('data-tab');
      
      tabButtons.forEach(btn => btn.classList.remove('active'));
      tabContents.forEach(content => content.classList.remove('active'));
      
      button.classList.add('active');
      const selectedContent = document.getElementById(tabId);
      if (selectedContent) {
        selectedContent.classList.add('active');
      }
    });
  });
}

function setupSensorInterface() {
  const sensorContainer = document.getElementById('sensorContainer');
  if (!sensorContainer) return;
  
  sensorContainer.innerHTML = `
    <div class="sensor-controls">
      <button id="scanButton" class="scan-button">
        Initialisation...
      </button>
      <div id="scanError" class="error-message" style="display: none;"></div>
    </div>
    <div id="deviceList" class="device-list"></div>
  `;
  
  scanButton = document.getElementById('scanButton');
  deviceList = document.getElementById('deviceList');
  errorDisplay = document.getElementById('scanError');
  
  if (scanButton) {
    scanButton.addEventListener('click', () => {
      if (scanButton.disabled) return;
      
      if (areBothSensorsOperational()) {
        console.log('[UI] Capteurs deja operationnels');
        return;
      }
      
      startScanning();
    });
  }
}

// ==========================================
// INITIALISATION
// ==========================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('[App] Initialisation...');
  
  setupTabs();
  setupSensorInterface();
  setupNoble();
  
  console.log('[App] Pret - Version corrigee');
});

// ==========================================
// NETTOYAGE A LA FERMETURE
// ==========================================
if (window.require) {
  const { ipcRenderer } = window.require('electron');
  
  ipcRenderer.on('app-closing', () => {
    console.log('[App] Fermeture, nettoyage...');
    
    // Arrêter tous les timers
    globalState.reconnectTimers.forEach(timerId => clearTimeout(timerId));
    
    // Nettoyer tous les périphériques
    globalState.peripherals.forEach((peripheral, address) => {
      cleanupPeripheral(address);
      try {
        if (peripheral.state === 'connected') {
          peripheral.disconnect();
        }
      } catch (e) {}
    });
    
    // Arrêter Noble
    try {
      noble.stopScanning();
    } catch (e) {}
    
    setTimeout(() => {
      ipcRenderer.send('cleanup-complete');
    }, 200);
  });
}