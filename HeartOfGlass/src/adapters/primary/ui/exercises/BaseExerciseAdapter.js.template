/**
 * BaseExerciseAdapter.js
 *
 * Classe abstraite de base pour tous les exercices suivant l'architecture hexagonale
 *
 * Fournit :
 * - Template method pattern pour lifecycle
 * - MÃ©thodes communes I/O
 * - Gestion Ã©tat via StateManager
 * - Hooks pour personnalisation
 *
 * Usage :
 * ```
 * class MonExercice extends BaseExerciseAdapter {
 *   setupServices() { ... }
 *   setupUseCase() { ... }
 *   handleUpdate(sensorData, position) { ... }
 * }
 * ```
 *
 * Architecture : Adapters/Primary/UI/Exercises
 *
 * @abstract
 */

const Exercise = require('../../../../core/domain/entities/Exercise');
const ExerciseStateManager = require('../../../../core/domain/services/ExerciseStateManager');

class BaseExerciseAdapter extends Exercise {
  /**
   * Constructeur de base
   *
   * @param {Object} params - ParamÃ¨tres
   * @param {string} params.name - Nom de l'exercice
   * @param {number} params.duration - DurÃ©e en ms
   * @param {Object} params.audioOrchestrator - Orchestrateur audio
   * @param {Object} params.state - State global
   * @param {Object} params.calibrationOrchestrator - Orchestrateur calibration
   * @param {Object} params.audioUIController - ContrÃ´leur UI audio
   * @param {Object} params.config - Configuration exercice
   * @param {Object} params.audioSettings - ParamÃ¨tres audio
   */
  constructor(params) {
    // VÃ©rifier classe abstraite
    if (new.target === BaseExerciseAdapter) {
      throw new Error('BaseExerciseAdapter est une classe abstraite et ne peut pas Ãªtre instanciÃ©e directement');
    }

    // Appeler constructeur parent
    super({
      name: params.name,
      duration: params.duration
    });

    // DÃ©pendances externes (I/O)
    this.audioOrchestrator = params.audioOrchestrator;
    this.state = params.state;
    this.calibrationOrchestrator = params.calibrationOrchestrator;
    this.audioUIController = params.audioUIController;

    // Configuration
    this.config = params.config;
    this.audioSettings = params.audioSettings;

    // Ã‰tat lifecycle
    this.checkIntervalId = null;
    this.originalAudioParams = null;

    // ğŸ¯ HOOKS: Les classes dÃ©rivÃ©es doivent implÃ©menter
    this.setupServices();
    this.setupStateManager();
    this.setupUseCase();
    this.initializeState();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HOOKS - Ã€ IMPLÃ‰MENTER PAR LES CLASSES DÃ‰RIVÃ‰ES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Configure les services domaine
   * @abstract
   * @example
   * setupServices() {
   *   this.directionDetector = new DirectionDetector(this.config);
   *   this.sensorAnalyzer = new SensorAnalyzer(this.config);
   * }
   */
  setupServices() {
    throw new Error('setupServices() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }

  /**
   * Configure le StateManager
   * @abstract
   * @example
   * setupStateManager() {
   *   this.stateManager = new ExerciseStateManager(this.config);
   * }
   */
  setupStateManager() {
    throw new Error('setupStateManager() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }

  /**
   * Configure le Use Case
   * @abstract
   * @example
   * setupUseCase() {
   *   this.monUseCase = new MonUseCase({
   *     service1: this.service1,
   *     service2: this.service2,
   *     config: this.config
   *   });
   * }
   */
  setupUseCase() {
    throw new Error('setupUseCase() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }

  /**
   * Initialise l'Ã©tat de l'exercice
   * @abstract
   * @example
   * initializeState() {
   *   this.propriete1 = null;
   *   this.propriete2 = null;
   *   this.stateManager.applyInitialState(this);
   * }
   */
  initializeState() {
    throw new Error('initializeState() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }

  /**
   * Traite la mise Ã  jour du capteur (logique mÃ©tier)
   * @abstract
   * @param {Object} sensorData - DonnÃ©es capteur
   * @param {string} position - Position capteur
   * @param {number} now - Timestamp
   */
  handleUpdate(sensorData, position, now) {
    throw new Error('handleUpdate() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }

  /**
   * Hook: Validation avant dÃ©marrage
   * @returns {boolean} True si validation OK
   */
  validateBeforeStart() {
    // Par dÃ©faut, vÃ©rifie calibration
    if (!this.calibrationOrchestrator) {
      console.error(`[${this.name}] âŒ CalibrationOrchestrator non disponible !`);
      return false;
    }
    return true;
  }

  /**
   * Hook: Configuration audio custom
   */
  configureAudio() {
    // Par dÃ©faut, applique audioSettings
    if (this.audioSettings) {
      this.audioOrchestrator.setGrainSize(this.audioSettings.grainSize);
      this.audioOrchestrator.setOverlap(this.audioSettings.overlap);
    }
  }

  /**
   * Hook: Logs custom au dÃ©marrage
   */
  logStart() {
    console.log(`\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    console.log(`[${this.name}] DÃ©marrage...`);
    console.log(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`);
  }

  /**
   * Hook: Cleanup custom Ã  l'arrÃªt
   */
  cleanupOnStop() {
    // Par dÃ©faut: rien
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEMPLATE METHODS - IMPLÃ‰MENTATION COMMUNE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * DÃ©marre l'exercice (Template Method)
   * @final
   */
  start() {
    if (this.isActive) {
      console.warn(`[${this.name}] Exercice dÃ©jÃ  actif`);
      return false;
    }

    // 1. LOGS
    this.logStart();

    // 2. VALIDATION
    if (!this.validateBeforeStart()) {
      return false;
    }

    // 3. SAUVEGARDE PARAMÃˆTRES AUDIO
    const currentParams = this.state.getAudioParameters();
    this.originalAudioParams = {
      grainSize: currentParams.grainSize,
      overlap: currentParams.overlap
    };

    // 4. CONFIGURATION AUDIO
    this.configureAudio();

    // 5. ACTIVATION
    this.isActive = true;
    this.startTime = Date.now();

    // 6. RÃ‰INITIALISATION Ã‰TAT (via StateManager)
    if (this.stateManager && this.stateManager.applyResetState) {
      this.stateManager.applyResetState(this);
    }

    // 7. DÃ‰MARRAGE AUDIO
    if (this.audioOrchestrator) {
      const audioState = this.state.getAudioState();
      if (!audioState.isPlaying) {
        this.audioOrchestrator.togglePlayPause();
        console.log(`[${this.name}] Audio dÃ©marrÃ©`);
      }
    }

    // 8. MONITORING
    this._startMonitoring();

    // 9. NOTIFICATION UI
    this._notifyUI('EXERCISE_STARTED', {
      name: this.name,
      duration: this.duration
    });

    return true;
  }

  /**
   * ArrÃªte l'exercice (Template Method)
   * @final
   */
  stop() {
    if (!this.isActive) {
      console.warn(`[${this.name}] Exercice non actif`);
      return false;
    }

    console.log(`\n[${this.name}] ArrÃªt...`);

    // 1. DÃ‰SACTIVATION
    this.isActive = false;

    // 2. ARRÃŠT MONITORING
    this._stopMonitoring();

    // 3. STATISTIQUES
    const stats = this.getStats();

    // 4. LOGS
    console.log(`\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    console.log(`[${this.name}] Exercice terminÃ©`);
    console.log(`DurÃ©e: ${stats.duration}s`);
    console.log(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`);

    // 5. CLEANUP
    this.cleanupOnStop();

    // 6. RESTAURATION AUDIO
    if (this.originalAudioParams) {
      this.audioOrchestrator.setGrainSize(this.originalAudioParams.grainSize);
      this.audioOrchestrator.setOverlap(this.originalAudioParams.overlap);
    }

    // 7. ARRÃŠT AUDIO
    if (this.audioOrchestrator) {
      const audioState = this.state.getAudioState();
      if (audioState.isPlaying) {
        this.audioOrchestrator.togglePlayPause();
      }
    }

    // 8. NOTIFICATION UI
    this._notifyUI('EXERCISE_STOPPED', stats);

    return true;
  }

  /**
   * Traite mise Ã  jour capteur (Template Method)
   * @final
   */
  update(sensorData, position = 'DROIT') {
    if (!this.isActive) {
      return;
    }

    const now = Date.now();
    this.updateCount++;

    // DÃ©lÃ©gation Ã  la classe dÃ©rivÃ©e
    this.handleUpdate(sensorData, position, now);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MÃ‰THODES UTILITAIRES COMMUNES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * DÃ©marre le monitoring de progression
   * @private
   */
  _startMonitoring() {
    this.checkIntervalId = setInterval(() => {
      this._checkProgress();
    }, this.config?.checkInterval || 1000);
  }

  /**
   * ArrÃªte le monitoring
   * @private
   */
  _stopMonitoring() {
    if (this.checkIntervalId) {
      clearInterval(this.checkIntervalId);
      this.checkIntervalId = null;
    }
  }

  /**
   * VÃ©rifie la progression et auto-arrÃªt si terminÃ©
   * @private
   */
  _checkProgress() {
    if (!this.isActive) {
      return;
    }

    const progress = this.getProgress();

    // Notification UI progression
    if (this.updateCount % 10 === 0) {
      this._notifyUI('PROGRESS_UPDATE', {
        progress,
        elapsed: this.getElapsedTime(),
        remaining: this.getRemainingTime()
      });
    }

    // Auto-arrÃªt si terminÃ©
    if (this.isCompleted()) {
      console.log(`[${this.name}] â° DurÃ©e atteinte - ArrÃªt automatique`);
      this.stop();
    }
  }

  /**
   * Notifie l'UI d'un Ã©vÃ©nement
   * @protected
   * @param {string} eventType - Type d'Ã©vÃ©nement
   * @param {Object} data - DonnÃ©es Ã  envoyer
   */
  _notifyUI(eventType, data = {}) {
    if (this.audioUIController && this.audioUIController.notifyExerciseEvent) {
      this.audioUIController.notifyExerciseEvent({
        type: eventType,
        exerciseName: this.name,
        timestamp: Date.now(),
        data
      });
    }
  }

  /**
   * Obtient l'Ã©tat actuel pour le Use Case
   * @protected
   * @returns {Object} Ã‰tat actuel
   */
  _getState() {
    // Ã€ override par classe dÃ©rivÃ©e si nÃ©cessaire
    return {};
  }

  /**
   * Applique les mises Ã  jour d'Ã©tat
   * @protected
   * @param {Object} updates - Mises Ã  jour
   */
  _applyStateUpdates(updates) {
    if (!updates) return;

    Object.keys(updates).forEach(key => {
      this[key] = updates[key];
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MÃ‰THODES ABSTRAITES (Ã  implÃ©menter)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Obtient les statistiques de l'exercice
   * @abstract
   * @returns {Object} Statistiques
   */
  getStats() {
    throw new Error('getStats() doit Ãªtre implÃ©mentÃ©e par la classe dÃ©rivÃ©e');
  }
}

module.exports = BaseExerciseAdapter;
